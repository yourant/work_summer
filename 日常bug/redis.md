# 分布式锁
实现逻辑

1. 在执行函数时先判断是否有特殊key的缓存数据存在

2. 如果不存在特殊key的缓存数据, 则新建, 如果存在, 则 sleep然后继续检查, 超过一定检查次数报错, 并且将该key 和任务执行信息, 保存下来并且以某种方式通知到具体人

3. 在函数执行完成后需要删除该特殊key, 这样后面的任务就能执行
   
# 主从模式
> 此种模式下, 能实现redis的容灾备份 和 读写分离

### 主从模式全量同步
> slave节点发起全量同步, 当master节点收到全量同步命令后开始执行BGSAVE, 并且将开始执行BGSAVE之后发生变更的数据写入缓冲区, 当BGSAVE执行完成之后,将rdb文件发送到slave节点, 发送完成后继续发送缓冲区中的数据,slave节点收到新的rdb文件后会丢弃所有旧数据并且载入新收到的rdb文件, 当rdb载入完成后, 开始写入发送过来的缓冲区记录

### 主从模式增量同步
> 全量同步完成之后, 后续master节点收到写入命令, 就会自动同步到slave 节点, 以此保证数据一致性


### 容灾备份

> 使用 slave 节点 实现 redis 的 持久化存储 AOF 或 RDB, 以此来减轻master服务的负载, 当master节点出现不可预知的错误导致 数据丢失, 可以从slave找到原数据的备份 以此来恢复数据, slave 节点使用 AOF (追加日志) 或者是 RDB (镜像文件)的方式来持久化存储, 一般来讲会二者结合使用

#### RDB 
```
BGSAVE (fork子进程)
SAVE (不会fork子进程)

先将数据集写入一个临时文件, 当快照执行完成后再覆盖原来的rdb文件,用二进制压缩存储
配置如下 save 900 1 , 每900s检查一次, 有一个key对应的数据发生改变则做以此快照, 以上一次执行快照为 数据改变检查点, 也可以手动执行备份(BGSAVE和SAVE), 数据恢复时会相对较快
```
#### AOF
appendfsync 配置 always(每次写操作执行日志写入), no(不执行) , everysec(每一秒执行一次), 以追加的方式写入日志文件

对服务性能会有一定影响, 需要权衡服务器性能和数据准确性


### 读写分离


1. master节点支持读写操作, 写(增删改), slave 只读, 然后只能同步master节点的写操作
2. 一台master可以配置多台 slave
3. master 宕机后不影响 slave的读取, 但是该集群不在支持写入, slave宕机后不影响master, 也就是master宕机后不会从slave中选举新的master
4. 读取数据可以从不同的 slave 节点中获取数据, 写数据只依赖master节点, 所以当 qps 很高例如达到 10w+, 就可以使用读写分离的方式来支撑

# 哨兵模式

